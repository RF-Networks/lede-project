--- a/drivers/usb/serial/option.c
+++ b/drivers/usb/serial/option.c
@@ -245,6 +245,8 @@ static void option_instat_callback(struc
 /* These Quectel products use Quectel's vendor ID */
 #define QUECTEL_PRODUCT_EC21			0x0121
 #define QUECTEL_PRODUCT_EC25			0x0125
+#define QUECTEL_PRODUCT_EG91			0x0191
+#define QUECTEL_PRODUCT_EG95			0x0195
 #define QUECTEL_PRODUCT_BG96			0x0296
 #define QUECTEL_PRODUCT_EP06			0x0306
 
@@ -1080,6 +1082,10 @@ static const struct usb_device_id option
 	  .driver_info = RSVD(4) },
 	{ USB_DEVICE(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_BG96),
 	  .driver_info = RSVD(4) },
+    { USB_DEVICE(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_EG91),
+	  .driver_info = RSVD(4) },
+    { USB_DEVICE(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_EG95),
+	  .driver_info = RSVD(4) },
 	{ USB_DEVICE(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_EP06),
 	  .driver_info = RSVD(4) | RSVD(5) },
 	{ USB_DEVICE(CMOTECH_VENDOR_ID, CMOTECH_PRODUCT_6001) },
@@ -1970,6 +1976,7 @@ static struct usb_serial_driver option_1
 #ifdef CONFIG_PM
 	.suspend           = usb_wwan_suspend,
 	.resume            = usb_wwan_resume,
+    .reset_resume      = usb_wwan_resume,
 #endif
 };
 
@@ -2007,6 +2014,10 @@ static int option_probe(struct usb_seria
 	    iface_desc->bInterfaceClass != USB_CLASS_CDC_DATA)
 		return -ENODEV;
 
+    if (serial->dev->descriptor.idVendor == cpu_to_le16(0x2C7C) &&
+        serial->interface->cur_altsetting->desc.bInterfaceNumber >= 4)
+        return -ENODEV;
+
 	/* Store the device flags so we can use them during attach. */
 	usb_set_serial_data(serial, (void *)device_flags);
 
--- a/drivers/usb/serial/usb_wwan.c
+++ b/drivers/usb/serial/usb_wwan.c
@@ -502,6 +502,12 @@ static struct urb *usb_wwan_setup_urb(st
 			  usb_sndbulkpipe(serial->dev, endpoint) | dir,
 			  buf, len, callback, ctx);
 
+    if (dir == USB_DIR_OUT) {
+        struct usb_device_descriptor *desc = &serial->dev->descriptor;
+        if (desc->idVendor == cpu_to_le16(0x2C7C))
+            urb->transfer_flags |= URB_ZERO_PACKET;
+    }
+
 	return urb;
 }
 
--- a/drivers/net/usb/qmi_wwan.c
+++ b/drivers/net/usb/qmi_wwan.c
@@ -446,6 +446,22 @@ static const u8 default_modem_addr[ETH_A
 
 static const u8 buggy_fw_addr[ETH_ALEN] = {0x00, 0xa0, 0xc6, 0x00, 0x00, 0x00};
 
+struct sk_buff* qmi_wwan_tx_fixup(struct usbnet *dev, struct sk_buff *skb, gfp_t flags)
+{
+    if (dev->udev->descriptor.idVendor != cpu_to_le16(0x2C7C))
+        return skb;
+
+    // Skip Ethernet header from message
+    if (skb_pull(skb, ETH_HLEN)) {
+        return skb;
+    } else {
+        dev_err(&dev->intf->dev, "Packet Dropped");
+    }
+    // Filter the packet out, release it
+    dev_kfree_skb_any(skb);
+    return NULL;
+}
+
 /* Make up an ethernet header if the packet doesn't have one.
  *
  * A firmware bug common among several devices cause them to send raw
@@ -472,6 +488,9 @@ static int qmi_wwan_rx_fixup(struct usbn
 	bool rawip = info->flags & QMI_WWAN_FLAG_RAWIP;
 	__be16 proto;
 
+    if (dev->udev->descriptor.idVendor != cpu_to_le16(0x2C7C))
+        return 1;
+
 	/* This check is no longer done by usbnet */
 	if (skb->len < dev->net->hard_header_len)
 		return 0;
@@ -740,6 +759,20 @@ static int qmi_wwan_bind(struct usbnet *
 	}
 	dev->net->netdev_ops = &qmi_wwan_netdev_ops;
 	dev->net->sysfs_groups[0] = &qmi_wwan_sysfs_attr_group;
+
+    if (dev->udev->descriptor.idVendor == cpu_to_le16(0x2C7C)) {
+        dev_info(&intf->dev, "Quectel EC25&EC21&EG91&EG95&EP06&EM06&BG96&AG35 work on RawIP mode\n");
+        dev->net->flags |= IFF_NOARP;
+
+        usb_control_msg(
+            interface_to_usbdev(intf),
+            usb_sndctrlpipe(interface_to_usbdev(intf), 0),
+            0x22, //USB_CDC_REQ_SET_CONTROL_LINE_STATE
+            0x21, //USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE
+            1, //active CDC DTR
+            intf->cur_altsetting->desc.bInterfaceNumber,
+            NULL, 0, 100);
+    }
 err:
 	return status;
 }
@@ -831,6 +864,7 @@ static const struct driver_info	qmi_wwan
 	.unbind		= qmi_wwan_unbind,
 	.manage_power	= qmi_wwan_manage_power,
 	.rx_fixup       = qmi_wwan_rx_fixup,
+    .tx_fixup       = qmi_wwan_tx_fixup,
 };
 
 static const struct driver_info	qmi_wwan_info_quirk_dtr = {
@@ -840,6 +874,7 @@ static const struct driver_info	qmi_wwan
 	.unbind		= qmi_wwan_unbind,
 	.manage_power	= qmi_wwan_manage_power,
 	.rx_fixup       = qmi_wwan_rx_fixup,
+    .tx_fixup       = qmi_wwan_tx_fixup,
 	.data           = QMI_WWAN_QUIRK_DTR,
 };
 
@@ -1250,6 +1285,8 @@ static const struct usb_device_id produc
 	{QMI_FIXED_INTF(0x1e0e, 0x9001, 5)},	/* SIMCom 7230E */
 	{QMI_QUIRK_SET_DTR(0x2c7c, 0x0125, 4)},	/* Quectel EC25, EC20 R2.0  Mini PCIe */
 	{QMI_QUIRK_SET_DTR(0x2c7c, 0x0121, 4)},	/* Quectel EC21 Mini PCIe */
+    {QMI_FIXED_INTF(0x2c7c, 0x0191, 4)},	/* Quectel EG91 */
+    {QMI_FIXED_INTF(0x2c7c, 0x0195, 4)},	/* Quectel EG95 */
 	{QMI_FIXED_INTF(0x2c7c, 0x0296, 4)},	/* Quectel BG96 */
 	{QMI_QUIRK_SET_DTR(0x2c7c, 0x0306, 4)},	/* Quectel EP06 Mini PCIe */
 
